# 魔兽世界

## 数据结构

工具类: `Util`

战士抽象类: `Warrior`

战士具体类: `Dragon` `Iceman` `Lion` `Ninja` `Wolf`

建筑抽象基类: `Build`

建筑具体类: `City` `Headquarter`

游戏类: `WorldOfWarcraft`

## 静态变量

在下面两种情景下使用静态变量

### 整个类共享一个变量

战士的初始生命值和初始攻击力属于第一种情况，所以设置为静态变量。

值得注意的是，派生类继承得到的静态变量和基类的静态变量是同一个地址，修改派生类继承的静态变量，基类的静态变量会同时改变。

所以需要对于每一个具体的战士类都单独设置静态变量。

### 封装全局变量

所有的输出都需要文件流和当前的游戏时间，所以将这两个变量设置为静态变量，封装在 `Util` 类中。

## 内存管理

所有的建筑和战士都使用 `new` 运算符创建。

`WorldOfWarcraft` 使用建筑指针的数组管理所有建筑，并在析构函数中释放所有建筑的内存。

`Headquarter` 使用战士指针的数组管理创建的所有战士，并在析构函数中释放所有战士的内存。

## 输出函数

### 封装位置

程序的层次为：`WorldOfWarcraft` 调用 `Build`，`Build` 调用 `Warrior`。

对于不同事件的输出，将输出函数封装在数据发生改变的类中。

比如说：

1. 到达城市事件，战士的数据并没有改变，只是建筑类的战士指针变了，所以把输出函数封装在建筑类中。
2. 战斗事件，战士的生命值发生了改变，所以把输出函数封装在战士类中。

### 行军顺序

输出函数要求从左向右输出。

但是对于红色士兵来说，为了保证数据不丢失，应当从右开始行军：即最右边城市的红色士兵先往右行军，然后第二右边城市的红色士兵再往右行军...最左边城市的红色士兵应该最后行军。

第一种解决方案是把事件输出函数和数据改变分开，但是这样做太麻烦了。

所以采用第二种解决方案，给城市添加一个成员变量 `backup_red_warrior_`。在每一次行军事件前，对所有城市进行更新，将 `red_warrior` 的值赋给 `backup_red_warrior`，并把 `red_warrior` 设为 `nullptr`。然后使用 `red_warrior` 接受到达的红色战士，使用 `backup_red_warrior` 的值传给下一个城市。

## 转型 Or 虚函数

基类指针可以指向派生类对象，但是基类指针不能调用派生类独有的方法。

有两种办法分别通过消耗时间或者空间来解决这个问题。

1. 消耗时间：使用 `dynamic_cast` 强制转型
2. 消耗空间：将所有派生类的方法都设置为基类的虚函数，并给基类一个空实现。

本项目采用第一种方法。

